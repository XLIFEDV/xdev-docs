// scripts/gen-docs.mjs
import fs from "fs/promises";
import path from "path";

const DOCS_DIR = path.resolve("docs");
const OUT_SIDEBARS = path.resolve("sidebars.js");
const OUT_NAV_FOOT = path.resolve("generated.links.json");

const isMarkdown = (p) => p.endsWith(".md") || p.endsWith(".mdx");

async function exists(p) {
  try { await fs.access(p); return true; } catch { return false; }
}

async function walk(dir) {
  const entries = await fs.readdir(dir, { withFileTypes: true });
  const files = [];
  for (const e of entries) {
    const full = path.join(dir, e.name);
    if (e.isDirectory()) files.push(...await walk(full));
    else if (e.isFile() && isMarkdown(full)) files.push(full);
  }
  return files;
}

// docs/posdevice/main.md -> posdevice/main
function toDocId(absPath) {
  const rel = path.relative(DOCS_DIR, absPath).replace(/\\/g, "/");
  return rel.replace(/\.(md|mdx)$/, "");
}

// folder label formatting: posdevice -> POSDEVICE, bank-system -> BANK SYSTEM
function folderLabel(name) {
  return name.replace(/[-_]/g, " ").toUpperCase();
}

// read frontmatter sidebar_position (optional)
function parseSidebarPosition(mdContent) {
  const m = mdContent.match(/^---\s*\n([\s\S]*?)\n---\s*\n/m);
  if (!m) return null;
  const fm = m[1];
  const pos = fm.match(/sidebar_position:\s*([0-9]+)/);
  return pos ? Number(pos[1]) : null;
}

async function buildSidebarTree(docFiles) {
  // Build nested categories based on folder structure
  const rootItems = [];
  const catMap = new Map(); // key folder path -> category object

  function getOrCreateCategory(folderPathParts) {
    let currentPath = "";
    let parentItems = rootItems;

    for (const part of folderPathParts) {
      currentPath = currentPath ? `${currentPath}/${part}` : part;

      if (!catMap.has(currentPath)) {
        const cat = {
          type: "category",
          label: part,        // istersen burada prettify yaparız
          collapsed: false,
          items: [],
        };
        catMap.set(currentPath, cat);
        parentItems.push(cat);
      }

      const cat = catMap.get(currentPath);
      parentItems = cat.items;
    }

    return parentItems;
  }

  for (const fileAbs of docFiles) {
    const docId = toDocId(fileAbs);
    const parts = docId.split("/");
    const fileName = parts.pop();         // main
    const folderParts = parts;            // ["posdevice"]

    const parentItems = getOrCreateCategory(folderParts);

    let position = null;
    try {
      const content = await fs.readFile(fileAbs, "utf8");
      position = parseSidebarPosition(content);
    } catch {}

    parentItems.push({
      type: "doc",
      id: folderParts.length ? `${folderParts.join("/")}/${fileName}` : fileName,
      ...(position != null ? { __pos: position } : {}),
    });
  }

  function sortItems(items) {
    for (const it of items) {
      if (it.type === "category") sortItems(it.items);
    }

    items.sort((a, b) => {
      // categories first
      if (a.type === "category" && b.type !== "category") return -1;
      if (a.type !== "category" && b.type === "category") return 1;

      const ap = a.__pos ?? 999999;
      const bp = b.__pos ?? 999999;
      if (ap !== bp) return ap - bp;

      const an = (a.label ?? a.id).toString().toLowerCase();
      const bn = (b.label ?? b.id).toString().toLowerCase();
      return an.localeCompare(bn);
    });

    for (const it of items) {
      if (it.__pos != null) delete it.__pos;
    }
  }

  sortItems(rootItems);
  return rootItems;
}

async function generateNavbarAndFooter() {
  const entries = await fs.readdir(DOCS_DIR, { withFileTypes: true });

  // Products = top-level folders under docs/
  const products = entries
    .filter(e => e.isDirectory())
    .map(e => e.name)
    // ignore folders starting with "_" (optional convention)
    .filter(name => !name.startsWith("_"))
    .sort((a, b) => a.localeCompare(b));

  const productLinks = [];
  for (const p of products) {
    // require docs/<product>/main.md or main.mdx
    const mainMd = path.join(DOCS_DIR, p, "main.md");
    const mainMdx = path.join(DOCS_DIR, p, "main.mdx");
    const hasMain = (await exists(mainMd)) || (await exists(mainMdx));

    if (!hasMain) {
      console.warn(`[gen-docs] Warning: docs/${p}/main.md(x) not found. Skipping navbar/footer link for "${p}".`);
      continue;
    }

    // routeBasePath: '/' olduğun için "/docs/..." yok.
    productLinks.push({
      label: folderLabel(p),
      to: `/${p}/main`,
    });
  }

  return { products: productLinks };
}

function writeSidebars(sidebarItems) {
  const sidebarsObj = {
    tutorialSidebar: sidebarItems,
  };

  const out = `// AUTO-GENERATED FILE. DO NOT EDIT MANUALLY.
// Generated by scripts/gen-docs.mjs

/** @type {import('@docusaurus/plugin-content-docs').SidebarsConfig} */
const sidebars = ${JSON.stringify(sidebarsObj, null, 2)};

module.exports = sidebars;
`;
  return fs.writeFile(OUT_SIDEBARS, out, "utf8");
}

async function main() {
  if (!(await exists(DOCS_DIR))) {
    console.error(`[gen-docs] docs/ folder not found at: ${DOCS_DIR}`);
    process.exit(1);
  }

  const docFiles = await walk(DOCS_DIR);
  const sidebarItems = await buildSidebarTree(docFiles);
  await writeSidebars(sidebarItems);

  const links = await generateNavbarAndFooter();
  await fs.writeFile(OUT_NAV_FOOT, JSON.stringify(links, null, 2), "utf8");

  console.log(`[gen-docs] sidebars.js + generated.links.json written. Docs found: ${docFiles.length}`);
}

main().catch((e) => {
  console.error("[gen-docs] Failed:", e);
  process.exit(1);
});
